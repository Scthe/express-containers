{
  "version": 3,
  "sources": ["../src/app/model/serviceWorkerShared.ts", "../src/app/service-worker.ts"],
  "sourcesContent": ["import { InterceptedFetchResponse } from 'app/utils/sendFakeRequest';\n\n/** Either header or query param */\nexport const WORKER_REQUEST_MARKER = 'is-quick-js';\nexport const WORKER_REQUEST_MARKER_VALUE = '1';\n\nexport const MESSAGE_TYPES = {\n  WORKER_REQUEST: 'WORKER_REQUEST',\n  HOST_RESPONSE: 'HOST_RESPONSE',\n} as const;\n\nexport interface WorkerFetchRequest {\n  type: (typeof MESSAGE_TYPES)['WORKER_REQUEST'];\n  url: string;\n}\n\nexport interface HostFetchResponse {\n  type: (typeof MESSAGE_TYPES)['HOST_RESPONSE'];\n  url: string;\n  resp: InterceptedFetchResponse | undefined;\n}\n", "// https://gist.github.com/kosamari/7c5d1e8449b2fbc97d372675f16b566e\n// https://web.dev/articles/two-way-communication-guide#channel-api\n// TODO [IGNORE] workbox?\n\nimport {\n  HostFetchResponse,\n  MESSAGE_TYPES,\n  WORKER_REQUEST_MARKER,\n  WORKER_REQUEST_MARKER_VALUE,\n  WorkerFetchRequest,\n} from './model/serviceWorkerShared';\nimport { InterceptedFetchResponse } from './utils/sendFakeRequest';\n\n// TODO [LOW] handle as tag in logs panel\n\n// eslint-disable-next-line no-console\nconst log = (...args: unknown[]) => console.log('[Service Worker]', ...args);\n\n// typesafe!\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst self2: ServiceWorkerGlobalScope = self as any;\n\nself2.addEventListener('install', function (_e) {\n  log('Service worker installed');\n\n  // force upgrade\n  self2.skipWaiting();\n});\n\nself2.addEventListener('fetch', function (event: FetchEvent) {\n  log(`Fetch request: '${event.request.url}'`);\n  // log(`Fetch request:`, event);\n\n  if (!isQuickJsRequest(event.request)) return;\n\n  log(`It's QuickJS request: '${event.request.url}'`);\n  const respAsync = getResponseFromVM(event);\n  event.respondWith(respAsync);\n});\n\nfunction isQuickJsRequest(request: Request) {\n  const byHeader =\n    request.headers.get(WORKER_REQUEST_MARKER) === WORKER_REQUEST_MARKER_VALUE;\n  const byQueryParam = request.url.includes(\n    `${WORKER_REQUEST_MARKER}=${WORKER_REQUEST_MARKER_VALUE}`\n  );\n\n  // from inside iframe\n  const byRefererQueryParam = request.referrer.includes(\n    `${WORKER_REQUEST_MARKER}=${WORKER_REQUEST_MARKER_VALUE}`\n  );\n\n  return byHeader || byQueryParam || byRefererQueryParam;\n}\n\ntype UrlResolver = (resp: InterceptedFetchResponse | undefined) => void;\n\nconst OUTSTANDING_REQUESTS: Record<\n  string, // url\n  UrlResolver[]\n> = {};\n\nfunction getResponseFromVM(event: FetchEvent) {\n  const url = event.request.url;\n\n  return new Promise<Response>((resolve, _rej) => {\n    const arr = OUTSTANDING_REQUESTS[url] || [];\n    OUTSTANDING_REQUESTS[url] = arr;\n\n    arr.push((resp) => {\n      const text =\n        typeof resp?.data === 'string' ? resp.data : '(invalid response data)';\n\n      const respObject = new Response(text, {\n        status: resp?.statusCode || 500,\n        headers: resp?.headers || {},\n      });\n      resolve(respObject);\n    });\n\n    postRequestToHost(url);\n  });\n\n  /*return new Response('mock-body', {\n    status: 202,\n    headers: {\n      'header-0': 'aaaaa',\n    },\n  });*/\n}\n\n/** TODO [IGNORE] Persist headers and content too. Trivial but I'm too lazy */\nasync function postRequestToHost(url: string) {\n  const clientsRaw = await self2.clients.matchAll({\n    includeUncontrolled: true,\n  });\n  const clients = clientsRaw || [];\n\n  log(`Post request to host url='${url}' to ${clients.length} clients`);\n  clients.forEach((client) => {\n    // log('post to client', client);\n    client.postMessage({\n      type: MESSAGE_TYPES.WORKER_REQUEST,\n      url,\n    } satisfies WorkerFetchRequest);\n  });\n}\n\nself2.addEventListener('message', (event) => {\n  log('Handle message', event.data);\n\n  if (event.data && event.data.type === MESSAGE_TYPES.HOST_RESPONSE) {\n    const data = event.data as HostFetchResponse;\n    const { url, resp } = data;\n\n    const awaitingRequests = OUTSTANDING_REQUESTS[url];\n    OUTSTANDING_REQUESTS[url] = [];\n    awaitingRequests.forEach((callback) => callback(resp));\n  }\n});\n"],
  "mappings": "mBAGO,IAAMA,EAAwB,cACxBC,EAA8B,IAE9BC,EAAgB,CAC3B,eAAgB,iBAChB,cAAe,eACjB,ECOA,IAAMC,EAAM,IAAIC,IAAoB,QAAQ,IAAI,mBAAoB,GAAGA,CAAI,EAIrEC,EAAkC,KAExCA,EAAM,iBAAiB,UAAW,SAAUC,EAAI,CAC9CH,EAAI,0BAA0B,EAG9BE,EAAM,YAAY,CACpB,CAAC,EAEDA,EAAM,iBAAiB,QAAS,SAAUE,EAAmB,CAI3D,GAHAJ,EAAI,mBAAmBI,EAAM,QAAQ,GAAG,GAAG,EAGvC,CAACC,EAAiBD,EAAM,OAAO,EAAG,OAEtCJ,EAAI,0BAA0BI,EAAM,QAAQ,GAAG,GAAG,EAClD,IAAME,EAAYC,EAAkBH,CAAK,EACzCA,EAAM,YAAYE,CAAS,CAC7B,CAAC,EAED,SAASD,EAAiBG,EAAkB,CAC1C,IAAMC,EACJD,EAAQ,QAAQ,IAAIE,CAAqB,IAAMC,EAC3CC,EAAeJ,EAAQ,IAAI,SAC/B,GAAGE,CAAqB,IAAIC,CAA2B,EACzD,EAGME,EAAsBL,EAAQ,SAAS,SAC3C,GAAGE,CAAqB,IAAIC,CAA2B,EACzD,EAEA,OAAOF,GAAYG,GAAgBC,CACrC,CAIA,IAAMC,EAGF,CAAC,EAEL,SAASP,EAAkBH,EAAmB,CAC5C,IAAMW,EAAMX,EAAM,QAAQ,IAE1B,OAAO,IAAI,QAAkB,CAACY,EAASC,IAAS,CAC9C,IAAMC,EAAMJ,EAAqBC,CAAG,GAAK,CAAC,EAC1CD,EAAqBC,CAAG,EAAIG,EAE5BA,EAAI,KAAMC,GAAS,CACjB,IAAMC,EACJ,OAAOD,GAAM,MAAS,SAAWA,EAAK,KAAO,0BAEzCE,EAAa,IAAI,SAASD,EAAM,CACpC,OAAQD,GAAM,YAAc,IAC5B,QAASA,GAAM,SAAW,CAAC,CAC7B,CAAC,EACDH,EAAQK,CAAU,CACpB,CAAC,EAEDC,EAAkBP,CAAG,CACvB,CAAC,CAQH,CAGA,eAAeO,EAAkBP,EAAa,CAI5C,IAAMQ,EAHa,MAAMrB,EAAM,QAAQ,SAAS,CAC9C,oBAAqB,EACvB,CAAC,GAC6B,CAAC,EAE/BF,EAAI,6BAA6Be,CAAG,QAAQQ,EAAQ,MAAM,UAAU,EACpEA,EAAQ,QAASC,GAAW,CAE1BA,EAAO,YAAY,CACjB,KAAMC,EAAc,eACpB,IAAAV,CACF,CAA8B,CAChC,CAAC,CACH,CAEAb,EAAM,iBAAiB,UAAYE,GAAU,CAG3C,GAFAJ,EAAI,iBAAkBI,EAAM,IAAI,EAE5BA,EAAM,MAAQA,EAAM,KAAK,OAASqB,EAAc,cAAe,CACjE,IAAMC,EAAOtB,EAAM,KACb,CAAE,IAAAW,EAAK,KAAAI,CAAK,EAAIO,EAEhBC,EAAmBb,EAAqBC,CAAG,EACjDD,EAAqBC,CAAG,EAAI,CAAC,EAC7BY,EAAiB,QAASC,GAAaA,EAAST,CAAI,CAAC,CACvD,CACF,CAAC",
  "names": ["WORKER_REQUEST_MARKER", "WORKER_REQUEST_MARKER_VALUE", "MESSAGE_TYPES", "log", "args", "self2", "_e", "event", "isQuickJsRequest", "respAsync", "getResponseFromVM", "request", "byHeader", "WORKER_REQUEST_MARKER", "WORKER_REQUEST_MARKER_VALUE", "byQueryParam", "byRefererQueryParam", "OUTSTANDING_REQUESTS", "url", "resolve", "_rej", "arr", "resp", "text", "respObject", "postRequestToHost", "clients", "client", "MESSAGE_TYPES", "data", "awaitingRequests", "callback"]
}
